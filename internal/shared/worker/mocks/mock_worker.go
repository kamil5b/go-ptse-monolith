// Code generated by MockGen. DO NOT EDIT.
// Source: internal/shared/worker/worker.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	worker "github.com/kamil5b/go-ptse-monolith/internal/shared/worker"

	gomock "github.com/golang/mock/gomock"
)

// MockOption is a mock of Option interface.
type MockOption struct {
	ctrl     *gomock.Controller
	recorder *MockOptionMockRecorder
}

// MockOptionMockRecorder is the mock recorder for MockOption.
type MockOptionMockRecorder struct {
	mock *MockOption
}

// NewMockOption creates a new mock instance.
func NewMockOption(ctrl *gomock.Controller) *MockOption {
	mock := &MockOption{ctrl: ctrl}
	mock.recorder = &MockOptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOption) EXPECT() *MockOptionMockRecorder {
	return m.recorder
}

// MockClient is a mock of Client interface.
type MockClient struct {
	ctrl     *gomock.Controller
	recorder *MockClientMockRecorder
}

// MockClientMockRecorder is the mock recorder for MockClient.
type MockClientMockRecorder struct {
	mock *MockClient
}

// NewMockClient creates a new mock instance.
func NewMockClient(ctrl *gomock.Controller) *MockClient {
	mock := &MockClient{ctrl: ctrl}
	mock.recorder = &MockClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockClient) EXPECT() *MockClientMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockClient) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockClientMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockClient)(nil).Close))
}

// Enqueue mocks base method.
func (m *MockClient) Enqueue(ctx context.Context, taskName string, payload worker.TaskPayload, options ...worker.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, taskName, payload}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Enqueue", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Enqueue indicates an expected call of Enqueue.
func (mr *MockClientMockRecorder) Enqueue(ctx, taskName, payload interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, taskName, payload}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enqueue", reflect.TypeOf((*MockClient)(nil).Enqueue), varargs...)
}

// EnqueueDelayed mocks base method.
func (m *MockClient) EnqueueDelayed(ctx context.Context, taskName string, payload worker.TaskPayload, delay time.Duration, options ...worker.Option) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, taskName, payload, delay}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EnqueueDelayed", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnqueueDelayed indicates an expected call of EnqueueDelayed.
func (mr *MockClientMockRecorder) EnqueueDelayed(ctx, taskName, payload, delay interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, taskName, payload, delay}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnqueueDelayed", reflect.TypeOf((*MockClient)(nil).EnqueueDelayed), varargs...)
}

// MockServer is a mock of Server interface.
type MockServer struct {
	ctrl     *gomock.Controller
	recorder *MockServerMockRecorder
}

// MockServerMockRecorder is the mock recorder for MockServer.
type MockServerMockRecorder struct {
	mock *MockServer
}

// NewMockServer creates a new mock instance.
func NewMockServer(ctrl *gomock.Controller) *MockServer {
	mock := &MockServer{ctrl: ctrl}
	mock.recorder = &MockServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockServer) EXPECT() *MockServerMockRecorder {
	return m.recorder
}

// RegisterHandler mocks base method.
func (m *MockServer) RegisterHandler(taskName string, handler worker.TaskHandler) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RegisterHandler", taskName, handler)
	ret0, _ := ret[0].(error)
	return ret0
}

// RegisterHandler indicates an expected call of RegisterHandler.
func (mr *MockServerMockRecorder) RegisterHandler(taskName, handler interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RegisterHandler", reflect.TypeOf((*MockServer)(nil).RegisterHandler), taskName, handler)
}

// Start mocks base method.
func (m *MockServer) Start(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockServerMockRecorder) Start(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockServer)(nil).Start), ctx)
}

// Stop mocks base method.
func (m *MockServer) Stop(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockServerMockRecorder) Stop(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockServer)(nil).Stop), ctx)
}

// MockScheduler is a mock of Scheduler interface.
type MockScheduler struct {
	ctrl     *gomock.Controller
	recorder *MockSchedulerMockRecorder
}

// MockSchedulerMockRecorder is the mock recorder for MockScheduler.
type MockSchedulerMockRecorder struct {
	mock *MockScheduler
}

// NewMockScheduler creates a new mock instance.
func NewMockScheduler(ctrl *gomock.Controller) *MockScheduler {
	mock := &MockScheduler{ctrl: ctrl}
	mock.recorder = &MockSchedulerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockScheduler) EXPECT() *MockSchedulerMockRecorder {
	return m.recorder
}

// AddJob mocks base method.
func (m *MockScheduler) AddJob(id, taskName string, schedule interface{}, payload worker.TaskPayload) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddJob", id, taskName, schedule, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddJob indicates an expected call of AddJob.
func (mr *MockSchedulerMockRecorder) AddJob(id, taskName, schedule, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddJob", reflect.TypeOf((*MockScheduler)(nil).AddJob), id, taskName, schedule, payload)
}

// DisableJob mocks base method.
func (m *MockScheduler) DisableJob(id string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DisableJob", id)
	ret0, _ := ret[0].(error)
	return ret0
}

// DisableJob indicates an expected call of DisableJob.
func (mr *MockSchedulerMockRecorder) DisableJob(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DisableJob", reflect.TypeOf((*MockScheduler)(nil).DisableJob), id)
}

// EnableJob mocks base method.
func (m *MockScheduler) EnableJob(id string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnableJob", id)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnableJob indicates an expected call of EnableJob.
func (mr *MockSchedulerMockRecorder) EnableJob(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableJob", reflect.TypeOf((*MockScheduler)(nil).EnableJob), id)
}

// RemoveJob mocks base method.
func (m *MockScheduler) RemoveJob(id string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveJob", id)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveJob indicates an expected call of RemoveJob.
func (mr *MockSchedulerMockRecorder) RemoveJob(id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveJob", reflect.TypeOf((*MockScheduler)(nil).RemoveJob), id)
}

// Start mocks base method.
func (m *MockScheduler) Start(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockSchedulerMockRecorder) Start(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockScheduler)(nil).Start), ctx)
}

// Stop mocks base method.
func (m *MockScheduler) Stop() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stop")
	ret0, _ := ret[0].(error)
	return ret0
}

// Stop indicates an expected call of Stop.
func (mr *MockSchedulerMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockScheduler)(nil).Stop))
}
